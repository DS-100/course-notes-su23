<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.361">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Principles and Techniques of Data Science - 4&nbsp; Pandas III</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../pandas_2/pandas_2.html" rel="prev">
<link href="../data100_logo.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../pandas_3/pandas_3.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Pandas III</span></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../index.html" class="sidebar-logo-link">
      <img src="../data100_logo.png" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Principles and Techniques of Data Science</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/DS-100/course-notes-su23" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="../Principles-and-Techniques-of-Data-Science.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../intro_lec/introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../pandas_1/pandas_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Pandas I</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../pandas_2/pandas_2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Pandas II</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../pandas_3/pandas_3.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Pandas III</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Pandas III</h2>
   
  <ul>
  <li><a href="#groupby-continued" id="toc-groupby-continued" class="nav-link active" data-scroll-target="#groupby-continued"><span class="header-section-number">4.1</span> <code>GroupBy()</code>, Continued</a>
  <ul>
  <li><a href="#aggregation-with-lambda-functions" id="toc-aggregation-with-lambda-functions" class="nav-link" data-scroll-target="#aggregation-with-lambda-functions"><span class="header-section-number">4.1.1</span> Aggregation with <code>lambda</code> Functions</a></li>
  <li><a href="#other-groupby-features" id="toc-other-groupby-features" class="nav-link" data-scroll-target="#other-groupby-features"><span class="header-section-number">4.1.2</span> Other <code>GroupBy</code> Features</a></li>
  <li><a href="#filtering-by-group" id="toc-filtering-by-group" class="nav-link" data-scroll-target="#filtering-by-group"><span class="header-section-number">4.1.3</span> Filtering by Group</a></li>
  </ul></li>
  <li><a href="#aggregating-data-with-pivot-tables" id="toc-aggregating-data-with-pivot-tables" class="nav-link" data-scroll-target="#aggregating-data-with-pivot-tables"><span class="header-section-number">4.2</span> Aggregating Data with Pivot Tables</a></li>
  <li><a href="#joining-tables" id="toc-joining-tables" class="nav-link" data-scroll-target="#joining-tables"><span class="header-section-number">4.3</span> Joining Tables</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-body" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Pandas III</span></h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Learning Outcomes
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Perform advanced aggregation using <code>.groupby()</code></li>
<li>Use the <code>pd.pivot_table</code> method to contruct a pivot table</li>
<li>Perform simple merges between DataFrames using <code>pd.merge()</code></li>
</ul>
</div>
</div>

<!-- ## More on `agg()` Function

Last time, we introduced the concept of aggregating data – we familiarized ourselves with `GroupBy` objects and used them as tools to consolidate and summarize a DataFrame. In this lecture, we will explore some advanced `.groupby` methods to show just how powerful of a resource they can be for understanding our data. We will also introduce other techniques for data aggregation to provide flexibility in how we manipulate our tables.  -->
<section id="groupby-continued" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="groupby-continued"><span class="header-section-number">4.1</span> <code>GroupBy()</code>, Continued</h2>
<p>As we learned last lecture, a <code>groupby</code> operation involves some combination of <strong>splitting a DataFrame into grouped subframes</strong>, <strong>applying a function</strong>, and <strong>combining the results</strong>.</p>
<p>For some arbitrary DataFrame <code>df</code> below, the code <code>df.groupby("year").agg(sum)</code> does the following:</p>
<ul>
<li><strong>Splits</strong> the DataFrame into sub-DataFrames with rows belonging to the same year.</li>
<li><strong>Applies</strong> the <code>sum</code> function to each column of each sub-DataFrame.</li>
<li><strong>Combines</strong> the results of <code>sum</code> into a single DataFrame, indexed by <code>year</code>.</li>
</ul>
<p><img src="images/groupby_demo.png" alt="groupby_demo" width="600"></p>
<section id="aggregation-with-lambda-functions" class="level3" data-number="4.1.1">
<h3 data-number="4.1.1" class="anchored" data-anchor-id="aggregation-with-lambda-functions"><span class="header-section-number">4.1.1</span> Aggregation with <code>lambda</code> Functions</h3>
<p>Throughout this note, we’ll work with the <code>elections</code> DataFrame.</p>
<div class="cell" data-execution_count="1">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>elections <span class="op">=</span> pd.read_csv(<span class="st">"data/elections.csv"</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>elections.head(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="1">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Year</th>
<th data-quarto-table-cell-role="th">Candidate</th>
<th data-quarto-table-cell-role="th">Party</th>
<th data-quarto-table-cell-role="th">Popular vote</th>
<th data-quarto-table-cell-role="th">Result</th>
<th data-quarto-table-cell-role="th">%</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1824</td>
<td>Andrew Jackson</td>
<td>Democratic-Republican</td>
<td>151271</td>
<td>loss</td>
<td>57.210122</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1824</td>
<td>John Quincy Adams</td>
<td>Democratic-Republican</td>
<td>113142</td>
<td>win</td>
<td>42.789878</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1828</td>
<td>Andrew Jackson</td>
<td>Democratic</td>
<td>642806</td>
<td>win</td>
<td>56.203927</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1828</td>
<td>John Quincy Adams</td>
<td>National Republican</td>
<td>500897</td>
<td>loss</td>
<td>43.796073</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>1832</td>
<td>Andrew Jackson</td>
<td>Democratic</td>
<td>702735</td>
<td>win</td>
<td>54.574789</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>What if we wish to aggregate our DataFrame using a non-standard function – for example, a function of our own design? We can do so by combining <code>.agg</code> with <code>lambda</code> expressions.</p>
<p>Let’s first consider a puzzle to jog our memory. We will attempt to find the <code>Candidate</code> from each <code>Party</code> with the highest <code>%</code> of votes.</p>
<p>A naive approach may be to group by the <code>Party</code> column and aggregate by the maximum.</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>elections.groupby(<span class="st">"Party"</span>).agg(<span class="bu">max</span>).head(<span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Year</th>
<th data-quarto-table-cell-role="th">Candidate</th>
<th data-quarto-table-cell-role="th">Popular vote</th>
<th data-quarto-table-cell-role="th">Result</th>
<th data-quarto-table-cell-role="th">%</th>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">Party</th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">American</td>
<td>1976</td>
<td>Thomas J. Anderson</td>
<td>873053</td>
<td>loss</td>
<td>21.554001</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">American Independent</td>
<td>1976</td>
<td>Lester Maddox</td>
<td>9901118</td>
<td>loss</td>
<td>13.571218</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">Anti-Masonic</td>
<td>1832</td>
<td>William Wirt</td>
<td>100715</td>
<td>loss</td>
<td>7.821583</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Anti-Monopoly</td>
<td>1884</td>
<td>Benjamin Butler</td>
<td>134294</td>
<td>loss</td>
<td>1.335838</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">Citizens</td>
<td>1980</td>
<td>Barry Commoner</td>
<td>233052</td>
<td>loss</td>
<td>0.270182</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Communist</td>
<td>1932</td>
<td>William Z. Foster</td>
<td>103307</td>
<td>loss</td>
<td>0.261069</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">Constitution</td>
<td>2016</td>
<td>Michael Peroutka</td>
<td>203091</td>
<td>loss</td>
<td>0.152398</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Constitutional Union</td>
<td>1860</td>
<td>John Bell</td>
<td>590901</td>
<td>loss</td>
<td>12.639283</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">Democratic</td>
<td>2020</td>
<td>Woodrow Wilson</td>
<td>81268924</td>
<td>win</td>
<td>61.344703</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Democratic-Republican</td>
<td>1824</td>
<td>John Quincy Adams</td>
<td>151271</td>
<td>win</td>
<td>57.210122</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>This approach is clearly wrong – the DataFrame claims that Woodrow Wilson won the presidency in 2020.</p>
<p>Why is this happening? Here, the <code>max</code> aggregation function is taken over every column <em>independently</em>. Among Democrats, <code>max</code> is computing:</p>
<ul>
<li>The most recent <code>Year</code> a Democratic candidate ran for president (2020)</li>
<li>The <code>Candidate</code> with the alphabetically “largest” name (“Woodrow Wilson”)</li>
<li>The <code>Result</code> with the alphabetically “largest” outcome (“win”)</li>
</ul>
<p>Instead, let’s try a different approach. We will:</p>
<ol type="1">
<li>Sort the DataFrame so that rows are in descending order of <code>%</code></li>
<li>Group by <code>Party</code> and select the first row of each sub-DataFrame</li>
</ol>
<p>While it may seem unintuitive, sorting <code>elections</code> by descending order of <code>%</code> is extremely helpful. If we then group by <code>Party</code>, the first row of each groupby object will contain information about the <code>Candidate</code> with the highest voter <code>%</code>.</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>elections_sorted_by_percent <span class="op">=</span> elections.sort_values(<span class="st">"%"</span>, ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>elections_sorted_by_percent.head(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Year</th>
<th data-quarto-table-cell-role="th">Candidate</th>
<th data-quarto-table-cell-role="th">Party</th>
<th data-quarto-table-cell-role="th">Popular vote</th>
<th data-quarto-table-cell-role="th">Result</th>
<th data-quarto-table-cell-role="th">%</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">114</td>
<td>1964</td>
<td>Lyndon Johnson</td>
<td>Democratic</td>
<td>43127041</td>
<td>win</td>
<td>61.344703</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">91</td>
<td>1936</td>
<td>Franklin Roosevelt</td>
<td>Democratic</td>
<td>27752648</td>
<td>win</td>
<td>60.978107</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">120</td>
<td>1972</td>
<td>Richard Nixon</td>
<td>Republican</td>
<td>47168710</td>
<td>win</td>
<td>60.907806</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">79</td>
<td>1920</td>
<td>Warren Harding</td>
<td>Republican</td>
<td>16144093</td>
<td>win</td>
<td>60.574501</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">133</td>
<td>1984</td>
<td>Ronald Reagan</td>
<td>Republican</td>
<td>54455472</td>
<td>win</td>
<td>59.023326</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>elections_sorted_by_percent.groupby(<span class="st">"Party"</span>).agg(<span class="kw">lambda</span> x : x.iloc[<span class="dv">0</span>]).head(<span class="dv">10</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Equivalent to the below code</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"># elections_sorted_by_percent.groupby("Party").agg('first').head(10)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Year</th>
<th data-quarto-table-cell-role="th">Candidate</th>
<th data-quarto-table-cell-role="th">Popular vote</th>
<th data-quarto-table-cell-role="th">Result</th>
<th data-quarto-table-cell-role="th">%</th>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">Party</th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">American</td>
<td>1856</td>
<td>Millard Fillmore</td>
<td>873053</td>
<td>loss</td>
<td>21.554001</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">American Independent</td>
<td>1968</td>
<td>George Wallace</td>
<td>9901118</td>
<td>loss</td>
<td>13.571218</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">Anti-Masonic</td>
<td>1832</td>
<td>William Wirt</td>
<td>100715</td>
<td>loss</td>
<td>7.821583</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Anti-Monopoly</td>
<td>1884</td>
<td>Benjamin Butler</td>
<td>134294</td>
<td>loss</td>
<td>1.335838</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">Citizens</td>
<td>1980</td>
<td>Barry Commoner</td>
<td>233052</td>
<td>loss</td>
<td>0.270182</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Communist</td>
<td>1932</td>
<td>William Z. Foster</td>
<td>103307</td>
<td>loss</td>
<td>0.261069</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">Constitution</td>
<td>2008</td>
<td>Chuck Baldwin</td>
<td>199750</td>
<td>loss</td>
<td>0.152398</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Constitutional Union</td>
<td>1860</td>
<td>John Bell</td>
<td>590901</td>
<td>loss</td>
<td>12.639283</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">Democratic</td>
<td>1964</td>
<td>Lyndon Johnson</td>
<td>43127041</td>
<td>win</td>
<td>61.344703</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Democratic-Republican</td>
<td>1824</td>
<td>Andrew Jackson</td>
<td>151271</td>
<td>loss</td>
<td>57.210122</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Notice how our code correctly determines that Lyndon Johnson from the Democratic Party has the highest voter <code>%</code>.</p>
<p>More generally, <code>lambda</code> functions are used to design custom aggregation functions that aren’t pre-defined by Python. The input parameter <code>x</code> to the <code>lambda</code> function is a <code>GroupBy</code> object. Therefore, it should make sense why <code>lambda x : x.iloc[0]</code> selects the first row in each groupby object.</p>
<p>In fact, there’s a few different ways to approach this problem. Each approach has different tradeoffs in terms of readability, performance, memory consumption, complexity, etc. We’ve given a few examples below.</p>
<p><strong>Note</strong>: Understanding these alternative solutions is not required. They are given to demonstrate the vast number of problem-solving approaches in <code>pandas</code>.</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Using the idxmax function</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>best_per_party <span class="op">=</span> elections.loc[elections.groupby(<span class="st">'Party'</span>)[<span class="st">'%'</span>].idxmax()]</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>best_per_party.head(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Year</th>
<th data-quarto-table-cell-role="th">Candidate</th>
<th data-quarto-table-cell-role="th">Party</th>
<th data-quarto-table-cell-role="th">Popular vote</th>
<th data-quarto-table-cell-role="th">Result</th>
<th data-quarto-table-cell-role="th">%</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">22</td>
<td>1856</td>
<td>Millard Fillmore</td>
<td>American</td>
<td>873053</td>
<td>loss</td>
<td>21.554001</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">115</td>
<td>1968</td>
<td>George Wallace</td>
<td>American Independent</td>
<td>9901118</td>
<td>loss</td>
<td>13.571218</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">6</td>
<td>1832</td>
<td>William Wirt</td>
<td>Anti-Masonic</td>
<td>100715</td>
<td>loss</td>
<td>7.821583</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">38</td>
<td>1884</td>
<td>Benjamin Butler</td>
<td>Anti-Monopoly</td>
<td>134294</td>
<td>loss</td>
<td>1.335838</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">127</td>
<td>1980</td>
<td>Barry Commoner</td>
<td>Citizens</td>
<td>233052</td>
<td>loss</td>
<td>0.270182</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Using the .drop_duplicates function</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>best_per_party2 <span class="op">=</span> elections.sort_values(<span class="st">'%'</span>).drop_duplicates([<span class="st">'Party'</span>], keep<span class="op">=</span><span class="st">'last'</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>best_per_party2.head(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Year</th>
<th data-quarto-table-cell-role="th">Candidate</th>
<th data-quarto-table-cell-role="th">Party</th>
<th data-quarto-table-cell-role="th">Popular vote</th>
<th data-quarto-table-cell-role="th">Result</th>
<th data-quarto-table-cell-role="th">%</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">148</td>
<td>1996</td>
<td>John Hagelin</td>
<td>Natural Law</td>
<td>113670</td>
<td>loss</td>
<td>0.118219</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">164</td>
<td>2008</td>
<td>Chuck Baldwin</td>
<td>Constitution</td>
<td>199750</td>
<td>loss</td>
<td>0.152398</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">110</td>
<td>1956</td>
<td>T. Coleman Andrews</td>
<td>States' Rights</td>
<td>107929</td>
<td>loss</td>
<td>0.174883</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">147</td>
<td>1996</td>
<td>Howard Phillips</td>
<td>Taxpayers</td>
<td>184656</td>
<td>loss</td>
<td>0.192045</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">136</td>
<td>1988</td>
<td>Lenora Fulani</td>
<td>New Alliance</td>
<td>217221</td>
<td>loss</td>
<td>0.237804</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
<section id="other-groupby-features" class="level3" data-number="4.1.2">
<h3 data-number="4.1.2" class="anchored" data-anchor-id="other-groupby-features"><span class="header-section-number">4.1.2</span> Other <code>GroupBy</code> Features</h3>
<p>There are many aggregation methods we can use with <code>.agg</code>. Some useful options are:</p>
<ul>
<li><a href="https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.mean.html#pandas.core.groupby.DataFrameGroupBy.mean"><code>.mean</code></a>: creates a new DataFrame with the mean value of each group</li>
<li><a href="https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.sum.html#pandas.core.groupby.DataFrameGroupBy.sum"><code>.sum</code></a>: creates a new DataFrame with the sum of each group</li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.core.groupby.GroupBy.max.html"><code>.max</code></a> and <a href="https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.min.html#pandas.core.groupby.DataFrameGroupBy.min"><code>.min</code></a>: creates a new DataFrame with the maximum/minimum value of each group</li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.core.groupby.GroupBy.size.html"><code>.size</code></a>: creates a new <strong>Series</strong> with the number of entries in each group</li>
<li><a href="https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count"><code>.count</code></a>: creates a new <strong>DataFrame</strong> with the number of entries, excluding missing values.</li>
</ul>
<p>Note the slight difference between <code>.size()</code> and <code>.count()</code>: while <code>.size()</code> returns a Series and counts the number of entries including the missing values, <code>.count()</code> returns a DataFrame and counts the number of entries in each column excluding missing values. Here’s an example:</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame({<span class="st">'letter'</span>:[<span class="st">'A'</span>,<span class="st">'A'</span>,<span class="st">'B'</span>,<span class="st">'C'</span>,<span class="st">'C'</span>,<span class="st">'C'</span>], </span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'num'</span>:[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,np.NaN,<span class="dv">4</span>], </span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'state'</span>:[np.NaN, <span class="st">'tx'</span>, <span class="st">'fl'</span>, <span class="st">'hi'</span>, np.NaN, <span class="st">'ak'</span>]})</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">letter</th>
<th data-quarto-table-cell-role="th">num</th>
<th data-quarto-table-cell-role="th">state</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>A</td>
<td>1.0</td>
<td>NaN</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>A</td>
<td>2.0</td>
<td>tx</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>B</td>
<td>3.0</td>
<td>fl</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>C</td>
<td>4.0</td>
<td>hi</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>C</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>C</td>
<td>4.0</td>
<td>ak</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>df.groupby(<span class="st">"letter"</span>).size()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>letter
A    2
B    1
C    3
dtype: int64</code></pre>
</div>
</div>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>df.groupby(<span class="st">"letter"</span>).count()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">num</th>
<th data-quarto-table-cell-role="th">state</th>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">letter</th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">A</td>
<td>2</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">B</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">C</td>
<td>2</td>
<td>2</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>You might recall <code>value_counts()</code> function we talked about in the previous note. It turns out <code>value_counts()</code> and <code>groupby.size()</code> have similar functionalities, except <code>value_counts()</code> sorts the result in descending order automatically.</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"letter"</span>].value_counts()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>letter
C    3
A    2
B    1
Name: count, dtype: int64</code></pre>
</div>
</div>
<p>In fact, these (and other) aggregation functions are so common that <code>pandas</code> allows for writing shorthand. Instead of explicitly stating the use of <code>.agg</code>, we can call the function directly on the <code>GroupBy</code> object.</p>
<p>For example, the following are equivalent:</p>
<ul>
<li><code>elections.groupby("Candidate").agg(mean)</code></li>
<li><code>elections.groupby("Candidate").mean()</code></li>
</ul>
<p>There are many other methods that <code>pandas</code> supports. You can check them out on the <a href="https://pandas.pydata.org/docs/reference/groupby.html"><code>pandas</code> documentation</a>.</p>
</section>
<section id="filtering-by-group" class="level3" data-number="4.1.3">
<h3 data-number="4.1.3" class="anchored" data-anchor-id="filtering-by-group"><span class="header-section-number">4.1.3</span> Filtering by Group</h3>
<p>Another common use for <code>GroupBy</code> objects is to filter data by group.</p>
<p><code>groupby.filter</code> takes an argument <span class="math inline">\(\text{f}\)</span>, where <span class="math inline">\(\text{f}\)</span> is a function that:</p>
<ul>
<li>Takes a <code>GroupBy</code> object as input</li>
<li>Returns a single <code>True</code> or <code>False</code> for the entire sub-DataFrame</li>
</ul>
<p><code>GroupBy</code> objects that correspond to <code>True</code> are returned in the final result, whereas those with a <code>False</code> value are not. Importantly, <code>groupby.filter</code> is different from <code>groupby.agg</code> in that the <em>entire</em> subframe is returned in the final DataFrame, not just a single row.</p>
<p>To illustrate how this happens, consider the following <code>.filter</code> function applied on some arbitrary data. Say we want to identify “tight” election years – that is, we want to find all rows that correspond to elections years where all candidates in that year won a similar portion of the total vote. Specifically, let’s find all rows corresponding to a year where no candidate won more than 45% of the total vote.</p>
<p>An equivalent way of framing this goal is to say:</p>
<ul>
<li>Find the years where the maximum <code>%</code> in that year is less than 45%</li>
<li>Return all DataFrame rows that correspond to these years</li>
</ul>
<p>For each year, we need to find the maximum <code>%</code> among <em>all</em> rows for that year. If this maximum <code>%</code> is lower than 45%, we will tell <code>pandas</code> to keep all rows corresponding to that year.</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>elections.groupby(<span class="st">"Year"</span>).<span class="bu">filter</span>(<span class="kw">lambda</span> sf: sf[<span class="st">"%"</span>].<span class="bu">max</span>() <span class="op">&lt;</span> <span class="dv">45</span>).head(<span class="dv">9</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="11">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Year</th>
<th data-quarto-table-cell-role="th">Candidate</th>
<th data-quarto-table-cell-role="th">Party</th>
<th data-quarto-table-cell-role="th">Popular vote</th>
<th data-quarto-table-cell-role="th">Result</th>
<th data-quarto-table-cell-role="th">%</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">23</td>
<td>1860</td>
<td>Abraham Lincoln</td>
<td>Republican</td>
<td>1855993</td>
<td>win</td>
<td>39.699408</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">24</td>
<td>1860</td>
<td>John Bell</td>
<td>Constitutional Union</td>
<td>590901</td>
<td>loss</td>
<td>12.639283</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">25</td>
<td>1860</td>
<td>John C. Breckinridge</td>
<td>Southern Democratic</td>
<td>848019</td>
<td>loss</td>
<td>18.138998</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">26</td>
<td>1860</td>
<td>Stephen A. Douglas</td>
<td>Northern Democratic</td>
<td>1380202</td>
<td>loss</td>
<td>29.522311</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">66</td>
<td>1912</td>
<td>Eugene V. Debs</td>
<td>Socialist</td>
<td>901551</td>
<td>loss</td>
<td>6.004354</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">67</td>
<td>1912</td>
<td>Eugene W. Chafin</td>
<td>Prohibition</td>
<td>208156</td>
<td>loss</td>
<td>1.386325</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">68</td>
<td>1912</td>
<td>Theodore Roosevelt</td>
<td>Progressive</td>
<td>4122721</td>
<td>loss</td>
<td>27.457433</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">69</td>
<td>1912</td>
<td>William Taft</td>
<td>Republican</td>
<td>3486242</td>
<td>loss</td>
<td>23.218466</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">70</td>
<td>1912</td>
<td>Woodrow Wilson</td>
<td>Democratic</td>
<td>6296284</td>
<td>win</td>
<td>41.933422</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>What’s going on here? In this example, we’ve defined our filtering function, <span class="math inline">\(\text{f}\)</span>, to be <code>lambda sf: sf["%"].max() &lt; 45</code>. This filtering function will find the maximum <code>"%"</code> value among all entries in the grouped subframe, which we call <code>sf</code>. If the maximum value is less than 45, then the filter function will return <code>True</code> and all rows in that grouped subframe will appear in the final output DataFrame.</p>
<p>Examine the DataFrame above. Notice how, in this preview of the first 9 rows, all entries from the years 1860 and 1912 appear. This means that in 1860 and 1912, no candidate in that year won more than 45% of the total vote.</p>
<p>You may ask: how is the <code>groupby.filter</code> procedure different to the boolean filtering we’ve seen previously? Boolean filtering considers <em>individual</em> rows when applying a boolean condition. For example, the code <code>elections[elections["%"] &lt; 45]</code> will check the <code>"%"</code> value of every single row in <code>elections</code>; if it is less than 45, then that row will be kept in the output. <code>groupby.filter</code>, in contrast, applies a boolean condition <em>across</em> all rows in a group. If not all rows in that group satisfy the condition specified by the filter, the entire group will be discarded in the output.</p>
</section>
</section>
<section id="aggregating-data-with-pivot-tables" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="aggregating-data-with-pivot-tables"><span class="header-section-number">4.2</span> Aggregating Data with Pivot Tables</h2>
<p>We know now that <code>.groupby</code> gives us the ability to group and aggregate data across our DataFrame. The examples above formed groups using just one column in the DataFrame. It’s possible to group by multiple columns at once by passing in a list of columns names to <code>.groupby</code>.</p>
<p>Let’s consider the <code>babynames</code> dataset from last lecture. In this problem, we will find the total number of baby names associated with each sex for each year. To do this, we’ll group by <em>both</em> the <code>"Year"</code> and <code>"Sex"</code> columns.</p>
<div class="cell" data-execution_count="12">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> urllib.request</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os.path</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Download data from the web directly</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>data_url <span class="op">=</span> <span class="st">"https://www.ssa.gov/oact/babynames/names.zip"</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>local_filename <span class="op">=</span> <span class="st">"data/babynames.zip"</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> os.path.exists(local_filename): <span class="co"># if the data exists don't download again</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> urllib.request.urlopen(data_url) <span class="im">as</span> resp, <span class="bu">open</span>(local_filename, <span class="st">'wb'</span>) <span class="im">as</span> f:</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        f.write(resp.read())</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Load data without unzipping the file</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> zipfile</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>babynames <span class="op">=</span> [] </span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> zipfile.ZipFile(local_filename, <span class="st">"r"</span>) <span class="im">as</span> zf:</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    data_files <span class="op">=</span> [f <span class="cf">for</span> f <span class="kw">in</span> zf.filelist <span class="cf">if</span> f.filename[<span class="op">-</span><span class="dv">3</span>:] <span class="op">==</span> <span class="st">"txt"</span>]</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> extract_year_from_filename(fn):</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">int</span>(fn[<span class="dv">3</span>:<span class="dv">7</span>])</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> f <span class="kw">in</span> data_files:</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>        year <span class="op">=</span> extract_year_from_filename(f.filename)</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> zf.<span class="bu">open</span>(f) <span class="im">as</span> fp:</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>            df <span class="op">=</span> pd.read_csv(fp, names<span class="op">=</span>[<span class="st">"Name"</span>, <span class="st">"Sex"</span>, <span class="st">"Count"</span>])</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>            df[<span class="st">"Year"</span>] <span class="op">=</span> year</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>            babynames.append(df)</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>babynames <span class="op">=</span> pd.concat(babynames)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>babynames.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="13">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Name</th>
<th data-quarto-table-cell-role="th">Sex</th>
<th data-quarto-table-cell-role="th">Count</th>
<th data-quarto-table-cell-role="th">Year</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>Mary</td>
<td>F</td>
<td>7065</td>
<td>1880</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>Anna</td>
<td>F</td>
<td>2604</td>
<td>1880</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>Emma</td>
<td>F</td>
<td>2003</td>
<td>1880</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>Elizabeth</td>
<td>F</td>
<td>1939</td>
<td>1880</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>Minnie</td>
<td>F</td>
<td>1746</td>
<td>1880</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Find the total number of baby names associated with each sex for each year in the data</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>babynames.groupby([<span class="st">"Year"</span>, <span class="st">"Sex"</span>])[[<span class="st">"Count"</span>]].agg(<span class="bu">sum</span>).head(<span class="dv">6</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="14">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Count</th>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">Year</th>
<th data-quarto-table-cell-role="th">Sex</th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td rowspan="2" data-quarto-table-cell-role="th" data-valign="top">1880</td>
<td data-quarto-table-cell-role="th">F</td>
<td>90994</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">M</td>
<td>110490</td>
</tr>
<tr class="odd">
<td rowspan="2" data-quarto-table-cell-role="th" data-valign="top">1881</td>
<td data-quarto-table-cell-role="th">F</td>
<td>91953</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">M</td>
<td>100737</td>
</tr>
<tr class="odd">
<td rowspan="2" data-quarto-table-cell-role="th" data-valign="top">1882</td>
<td data-quarto-table-cell-role="th">F</td>
<td>107847</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">M</td>
<td>113686</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Notice that both <code>"Year"</code> and <code>"Sex"</code> serve as the index of the DataFrame (they are both rendered in bold). We’ve created a <em>multindex</em> where two different index values, the year and sex, are used to uniquely identify each row.</p>
<p>This isn’t the most intuitive way of representing this data – and, because multindexes have multiple dimensions in their index, they can often be difficult to use.</p>
<p>Another strategy to aggregate across two columns is to create a pivot table. You saw these back in <a href="https://inferentialthinking.com/chapters/08/3/Cross-Classifying_by_More_than_One_Variable.html#pivot-tables-rearranging-the-output-of-group">Data 8</a>. One set of values is used to create the index of the table; another set is used to define the column names. The values contained in each cell of the table correspond to the aggregated data for each index-column pair.</p>
<p>The best way to understand pivot tables is to see one in action. Let’s return to our original goal of summing the total number of names associated with each combination of year and sex. We’ll call the <code>pandas</code> <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.pivot_table.html"><code>.pivot_table</code></a> method to create a new table.</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># The `pivot_table` method is used to generate a Pandas pivot table</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>babynames.pivot_table(index <span class="op">=</span> <span class="st">"Year"</span>, columns <span class="op">=</span> <span class="st">"Sex"</span>, values <span class="op">=</span> <span class="st">"Count"</span>, aggfunc <span class="op">=</span> np.<span class="bu">sum</span>).head(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="15">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th">Sex</th>
<th data-quarto-table-cell-role="th">F</th>
<th data-quarto-table-cell-role="th">M</th>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">Year</th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">1880</td>
<td>90994</td>
<td>110490</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1881</td>
<td>91953</td>
<td>100737</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">1882</td>
<td>107847</td>
<td>113686</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1883</td>
<td>112319</td>
<td>104625</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">1884</td>
<td>129019</td>
<td>114442</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Looks a lot better! Now, our DataFrame is structured with clear index-column combinations. Each entry in the pivot table represents the summed count of names for a given combination of <code>"Year"</code> and <code>"Sex"</code>.</p>
<p>Let’s take a closer look at the code implemented above.</p>
<ul>
<li><code>index = "Year"</code> specifies the column name in the original DataFrame that should be used as the index of the pivot table</li>
<li><code>columns = "Sex"</code> specifies the column name in the original DataFrame that should be used to generate the columns of the pivot table</li>
<li><code>values = "Count"</code> indicates what values from the original DataFrame should be used to populate the entry for each index-column combination</li>
<li><code>aggfunc = np.sum</code> tells <code>pandas</code> what function to use when aggregating the data specified by <code>values</code>. Here, we are <code>sum</code>ming the name counts for each pair of <code>"Year"</code> and <code>"Sex"</code></li>
</ul>
<p>We can even include multiple values in the index or columns of our pivot tables.</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>babynames_pivot <span class="op">=</span> babynames.pivot_table(</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    index<span class="op">=</span><span class="st">"Year"</span>,     <span class="co"># the rows (turned into index)</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    columns<span class="op">=</span><span class="st">"Sex"</span>,    <span class="co"># the column values</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    values<span class="op">=</span>[<span class="st">"Count"</span>, <span class="st">"Name"</span>], </span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    aggfunc<span class="op">=</span><span class="bu">max</span>,   <span class="co"># group operation</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>babynames_pivot.head(<span class="dv">6</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="16">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th colspan="2" data-quarto-table-cell-role="th" data-halign="left">Count</th>
<th colspan="2" data-quarto-table-cell-role="th" data-halign="left">Name</th>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">Sex</th>
<th data-quarto-table-cell-role="th">F</th>
<th data-quarto-table-cell-role="th">M</th>
<th data-quarto-table-cell-role="th">F</th>
<th data-quarto-table-cell-role="th">M</th>
</tr>
<tr class="header">
<th data-quarto-table-cell-role="th">Year</th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">1880</td>
<td>7065</td>
<td>9655</td>
<td>Zula</td>
<td>Zeke</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1881</td>
<td>6919</td>
<td>8769</td>
<td>Zula</td>
<td>Zeb</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">1882</td>
<td>8148</td>
<td>9557</td>
<td>Zula</td>
<td>Zed</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1883</td>
<td>8012</td>
<td>8894</td>
<td>Zula</td>
<td>Zeno</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">1884</td>
<td>9217</td>
<td>9388</td>
<td>Zula</td>
<td>Zollie</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1885</td>
<td>9128</td>
<td>8756</td>
<td>Zula</td>
<td>Zollie</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
<section id="joining-tables" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="joining-tables"><span class="header-section-number">4.3</span> Joining Tables</h2>
<p>When working on data science projects, we’re unlikely to have absolutely all the data we want contained in a single DataFrame – a real-world data scientist needs to grapple with data coming from multiple sources. If we have access to multiple datasets with related information, we can join two or more tables into a single DataFrame.</p>
<p>To put this into practice, we’ll revisit the <code>elections</code> dataset.</p>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>elections.head(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="17">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Year</th>
<th data-quarto-table-cell-role="th">Candidate</th>
<th data-quarto-table-cell-role="th">Party</th>
<th data-quarto-table-cell-role="th">Popular vote</th>
<th data-quarto-table-cell-role="th">Result</th>
<th data-quarto-table-cell-role="th">%</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1824</td>
<td>Andrew Jackson</td>
<td>Democratic-Republican</td>
<td>151271</td>
<td>loss</td>
<td>57.210122</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1824</td>
<td>John Quincy Adams</td>
<td>Democratic-Republican</td>
<td>113142</td>
<td>win</td>
<td>42.789878</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1828</td>
<td>Andrew Jackson</td>
<td>Democratic</td>
<td>642806</td>
<td>win</td>
<td>56.203927</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1828</td>
<td>John Quincy Adams</td>
<td>National Republican</td>
<td>500897</td>
<td>loss</td>
<td>43.796073</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>1832</td>
<td>Andrew Jackson</td>
<td>Democratic</td>
<td>702735</td>
<td>win</td>
<td>54.574789</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Say we want to understand the 2020 popularity of the names of each presidential candidate. To do this, we’ll need the combined data of <code>babynames</code> <em>and</em> <code>elections</code>.</p>
<p>We’ll start by creating a new column containing the first name of each presidential candidate. This will help us join each name in <code>elections</code> to the corresponding name data in <code>babynames</code>.</p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># This `str` operation splits each candidate's full name at each </span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co"># blank space, then takes just the candidiate's first name</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>elections[<span class="st">"First Name"</span>] <span class="op">=</span> elections[<span class="st">"Candidate"</span>].<span class="bu">str</span>.split().<span class="bu">str</span>[<span class="dv">0</span>]</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>elections.head(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="18">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Year</th>
<th data-quarto-table-cell-role="th">Candidate</th>
<th data-quarto-table-cell-role="th">Party</th>
<th data-quarto-table-cell-role="th">Popular vote</th>
<th data-quarto-table-cell-role="th">Result</th>
<th data-quarto-table-cell-role="th">%</th>
<th data-quarto-table-cell-role="th">First Name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1824</td>
<td>Andrew Jackson</td>
<td>Democratic-Republican</td>
<td>151271</td>
<td>loss</td>
<td>57.210122</td>
<td>Andrew</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1824</td>
<td>John Quincy Adams</td>
<td>Democratic-Republican</td>
<td>113142</td>
<td>win</td>
<td>42.789878</td>
<td>John</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1828</td>
<td>Andrew Jackson</td>
<td>Democratic</td>
<td>642806</td>
<td>win</td>
<td>56.203927</td>
<td>Andrew</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1828</td>
<td>John Quincy Adams</td>
<td>National Republican</td>
<td>500897</td>
<td>loss</td>
<td>43.796073</td>
<td>John</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>1832</td>
<td>Andrew Jackson</td>
<td>Democratic</td>
<td>702735</td>
<td>win</td>
<td>54.574789</td>
<td>Andrew</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Here, we'll only consider `babynames` data from 2020</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>babynames_2020 <span class="op">=</span> babynames[babynames[<span class="st">"Year"</span>]<span class="op">==</span><span class="dv">2020</span>]</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>babynames_2020.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Name</th>
<th data-quarto-table-cell-role="th">Sex</th>
<th data-quarto-table-cell-role="th">Count</th>
<th data-quarto-table-cell-role="th">Year</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>Olivia</td>
<td>F</td>
<td>17641</td>
<td>2020</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>Emma</td>
<td>F</td>
<td>15656</td>
<td>2020</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>Ava</td>
<td>F</td>
<td>13160</td>
<td>2020</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>Charlotte</td>
<td>F</td>
<td>13065</td>
<td>2020</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>Sophia</td>
<td>F</td>
<td>13036</td>
<td>2020</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Now, we’re ready to join the two tables. <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.merge.html"><code>pd.merge</code></a> is the <code>pandas</code> method used to join DataFrames together. The <code>left</code> and <code>right</code> parameters are used to specify the DataFrames to be joined. The <code>left_on</code> and <code>right_on</code> parameters are assigned to the string names of the columns to be used when performing the join. These two <code>on</code> parameters tell <code>pandas</code> what values should act as pairing keys to determine which rows to merge across the DataFrames. We’ll talk more about this idea of a pairing key next lecture.</p>
<div class="cell" data-tags="[]" data-execution_count="20">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>merged <span class="op">=</span> pd.merge(left <span class="op">=</span> elections, right <span class="op">=</span> babynames_2020, <span class="op">\</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>                  left_on <span class="op">=</span> <span class="st">"First Name"</span>, right_on <span class="op">=</span> <span class="st">"Name"</span>)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>merged.head()</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Notice that pandas automatically specifies `Year_x` and `Year_y` </span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="co"># when both merged DataFrames have the same column name to avoid confusion</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Year_x</th>
<th data-quarto-table-cell-role="th">Candidate</th>
<th data-quarto-table-cell-role="th">Party</th>
<th data-quarto-table-cell-role="th">Popular vote</th>
<th data-quarto-table-cell-role="th">Result</th>
<th data-quarto-table-cell-role="th">%</th>
<th data-quarto-table-cell-role="th">First Name</th>
<th data-quarto-table-cell-role="th">Name</th>
<th data-quarto-table-cell-role="th">Sex</th>
<th data-quarto-table-cell-role="th">Count</th>
<th data-quarto-table-cell-role="th">Year_y</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1824</td>
<td>Andrew Jackson</td>
<td>Democratic-Republican</td>
<td>151271</td>
<td>loss</td>
<td>57.210122</td>
<td>Andrew</td>
<td>Andrew</td>
<td>F</td>
<td>12</td>
<td>2020</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1824</td>
<td>Andrew Jackson</td>
<td>Democratic-Republican</td>
<td>151271</td>
<td>loss</td>
<td>57.210122</td>
<td>Andrew</td>
<td>Andrew</td>
<td>M</td>
<td>6036</td>
<td>2020</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1828</td>
<td>Andrew Jackson</td>
<td>Democratic</td>
<td>642806</td>
<td>win</td>
<td>56.203927</td>
<td>Andrew</td>
<td>Andrew</td>
<td>F</td>
<td>12</td>
<td>2020</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1828</td>
<td>Andrew Jackson</td>
<td>Democratic</td>
<td>642806</td>
<td>win</td>
<td>56.203927</td>
<td>Andrew</td>
<td>Andrew</td>
<td>M</td>
<td>6036</td>
<td>2020</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>1832</td>
<td>Andrew Jackson</td>
<td>Democratic</td>
<td>702735</td>
<td>win</td>
<td>54.574789</td>
<td>Andrew</td>
<td>Andrew</td>
<td>F</td>
<td>12</td>
<td>2020</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation column-body">
  <div class="nav-page nav-page-previous">
      <a href="../pandas_2/pandas_2.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Pandas II</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb23" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> Pandas III</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="an">execute:</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="co">  echo: true</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="co">  html:</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="co">    code-fold: false</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="co">    code-tools: true</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="co">    toc: true</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="co">    toc-title: Pandas III</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="co">    page-layout: full</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a><span class="co">    theme:</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a><span class="co">      - cosmo</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a><span class="co">      - cerulean</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a><span class="co">    callout-icon: false</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a><span class="an">jupyter:</span><span class="co"> python3</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a><span class="fu">## Learning Outcomes</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Perform advanced aggregation using <span class="in">`.groupby()`</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Use the <span class="in">`pd.pivot_table`</span> method to contruct a pivot table</span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Perform simple merges between DataFrames using <span class="in">`pd.merge()`</span></span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- ## More on `agg()` Function</span></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a><span class="co">Last time, we introduced the concept of aggregating data – we familiarized ourselves with `GroupBy` objects and used them as tools to consolidate and summarize a DataFrame. In this lecture, we will explore some advanced `.groupby` methods to show just how powerful of a resource they can be for understanding our data. We will also introduce other techniques for data aggregation to provide flexibility in how we manipulate our tables.  --&gt;</span></span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a><span class="fu">## `GroupBy()`, Continued</span></span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a>As we learned last lecture, a <span class="in">`groupby`</span> operation involves some combination of **splitting a DataFrame into grouped subframes**, **applying a function**, and **combining the results**. </span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a>For some arbitrary DataFrame <span class="in">`df`</span> below, the code <span class="in">`df.groupby("year").agg(sum)`</span> does the following:</span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-36"><a href="#cb23-36" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Splits** the DataFrame into sub-DataFrames with rows belonging to the same year.</span>
<span id="cb23-37"><a href="#cb23-37" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Applies** the <span class="in">`sum`</span> function to each column of each sub-DataFrame.</span>
<span id="cb23-38"><a href="#cb23-38" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Combines** the results of <span class="in">`sum`</span> into a single DataFrame, indexed by <span class="in">`year`</span>.</span>
<span id="cb23-39"><a href="#cb23-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-40"><a href="#cb23-40" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;img</span> <span class="er">src</span><span class="ot">=</span><span class="st">"images/groupby_demo.png"</span> <span class="er">alt</span><span class="ot">=</span><span class="st">'groupby_demo'</span> <span class="er">width</span><span class="ot">=</span><span class="st">'600'</span><span class="kw">&gt;</span></span>
<span id="cb23-41"><a href="#cb23-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-42"><a href="#cb23-42" aria-hidden="true" tabindex="-1"></a><span class="fu">### Aggregation with `lambda` Functions</span></span>
<span id="cb23-43"><a href="#cb23-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-44"><a href="#cb23-44" aria-hidden="true" tabindex="-1"></a>Throughout this note, we'll work with the <span class="in">`elections`</span> DataFrame.</span>
<span id="cb23-45"><a href="#cb23-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-48"><a href="#cb23-48" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-49"><a href="#cb23-49" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb23-50"><a href="#cb23-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-51"><a href="#cb23-51" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb23-52"><a href="#cb23-52" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb23-53"><a href="#cb23-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-54"><a href="#cb23-54" aria-hidden="true" tabindex="-1"></a>elections <span class="op">=</span> pd.read_csv(<span class="st">"data/elections.csv"</span>)</span>
<span id="cb23-55"><a href="#cb23-55" aria-hidden="true" tabindex="-1"></a>elections.head(<span class="dv">5</span>)</span>
<span id="cb23-56"><a href="#cb23-56" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-57"><a href="#cb23-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-58"><a href="#cb23-58" aria-hidden="true" tabindex="-1"></a>What if we wish to aggregate our DataFrame using a non-standard function – for example, a function of our own design? We can do so by combining <span class="in">`.agg`</span> with <span class="in">`lambda`</span> expressions.</span>
<span id="cb23-59"><a href="#cb23-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-60"><a href="#cb23-60" aria-hidden="true" tabindex="-1"></a>Let's first consider a puzzle to jog our memory. We will attempt to find the <span class="in">`Candidate`</span> from each <span class="in">`Party`</span> with the highest <span class="in">`%`</span> of votes. </span>
<span id="cb23-61"><a href="#cb23-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-62"><a href="#cb23-62" aria-hidden="true" tabindex="-1"></a>A naive approach may be to group by the <span class="in">`Party`</span> column and aggregate by the maximum.</span>
<span id="cb23-63"><a href="#cb23-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-66"><a href="#cb23-66" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-67"><a href="#cb23-67" aria-hidden="true" tabindex="-1"></a>elections.groupby(<span class="st">"Party"</span>).agg(<span class="bu">max</span>).head(<span class="dv">10</span>)</span>
<span id="cb23-68"><a href="#cb23-68" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-69"><a href="#cb23-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-70"><a href="#cb23-70" aria-hidden="true" tabindex="-1"></a>This approach is clearly wrong – the DataFrame claims that Woodrow Wilson won the presidency in 2020.</span>
<span id="cb23-71"><a href="#cb23-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-72"><a href="#cb23-72" aria-hidden="true" tabindex="-1"></a>Why is this happening? Here, the <span class="in">`max`</span> aggregation function is taken over every column *independently*. Among Democrats, <span class="in">`max`</span> is computing:</span>
<span id="cb23-73"><a href="#cb23-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-74"><a href="#cb23-74" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The most recent <span class="in">`Year`</span> a Democratic candidate ran for president (2020)</span>
<span id="cb23-75"><a href="#cb23-75" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The <span class="in">`Candidate`</span> with the alphabetically "largest" name ("Woodrow Wilson")</span>
<span id="cb23-76"><a href="#cb23-76" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The <span class="in">`Result`</span> with the alphabetically "largest" outcome ("win")</span>
<span id="cb23-77"><a href="#cb23-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-78"><a href="#cb23-78" aria-hidden="true" tabindex="-1"></a>Instead, let's try a different approach. We will:</span>
<span id="cb23-79"><a href="#cb23-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-80"><a href="#cb23-80" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Sort the DataFrame so that rows are in descending order of <span class="in">`%`</span></span>
<span id="cb23-81"><a href="#cb23-81" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Group by <span class="in">`Party`</span> and select the first row of each sub-DataFrame</span>
<span id="cb23-82"><a href="#cb23-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-83"><a href="#cb23-83" aria-hidden="true" tabindex="-1"></a>While it may seem unintuitive, sorting <span class="in">`elections`</span> by descending order of <span class="in">`%`</span> is extremely helpful. If we then group by <span class="in">`Party`</span>, the first row of each groupby object will contain information about the <span class="in">`Candidate`</span> with the highest voter <span class="in">`%`</span>.</span>
<span id="cb23-84"><a href="#cb23-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-87"><a href="#cb23-87" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-88"><a href="#cb23-88" aria-hidden="true" tabindex="-1"></a>elections_sorted_by_percent <span class="op">=</span> elections.sort_values(<span class="st">"%"</span>, ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb23-89"><a href="#cb23-89" aria-hidden="true" tabindex="-1"></a>elections_sorted_by_percent.head(<span class="dv">5</span>)</span>
<span id="cb23-90"><a href="#cb23-90" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-91"><a href="#cb23-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-94"><a href="#cb23-94" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-95"><a href="#cb23-95" aria-hidden="true" tabindex="-1"></a>elections_sorted_by_percent.groupby(<span class="st">"Party"</span>).agg(<span class="kw">lambda</span> x : x.iloc[<span class="dv">0</span>]).head(<span class="dv">10</span>)</span>
<span id="cb23-96"><a href="#cb23-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-97"><a href="#cb23-97" aria-hidden="true" tabindex="-1"></a><span class="co"># Equivalent to the below code</span></span>
<span id="cb23-98"><a href="#cb23-98" aria-hidden="true" tabindex="-1"></a><span class="co"># elections_sorted_by_percent.groupby("Party").agg('first').head(10)</span></span>
<span id="cb23-99"><a href="#cb23-99" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-100"><a href="#cb23-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-101"><a href="#cb23-101" aria-hidden="true" tabindex="-1"></a>Notice how our code correctly determines that Lyndon Johnson from the Democratic Party has the highest voter <span class="in">`%`</span>.</span>
<span id="cb23-102"><a href="#cb23-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-103"><a href="#cb23-103" aria-hidden="true" tabindex="-1"></a>More generally, <span class="in">`lambda`</span> functions are used to design custom aggregation functions that aren't pre-defined by Python. The input parameter <span class="in">`x`</span> to the <span class="in">`lambda`</span> function is a <span class="in">`GroupBy`</span> object. Therefore, it should make sense why <span class="in">`lambda x : x.iloc[0]`</span> selects the first row in each groupby object.</span>
<span id="cb23-104"><a href="#cb23-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-105"><a href="#cb23-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-106"><a href="#cb23-106" aria-hidden="true" tabindex="-1"></a>In fact, there's a few different ways to approach this problem. Each approach has different tradeoffs in terms of readability, performance, memory consumption, complexity, etc. We've given a few examples below. </span>
<span id="cb23-107"><a href="#cb23-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-108"><a href="#cb23-108" aria-hidden="true" tabindex="-1"></a>**Note**: Understanding these alternative solutions is not required. They are given to demonstrate the vast number of problem-solving approaches in <span class="in">`pandas`</span>.</span>
<span id="cb23-109"><a href="#cb23-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-112"><a href="#cb23-112" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-113"><a href="#cb23-113" aria-hidden="true" tabindex="-1"></a><span class="co"># Using the idxmax function</span></span>
<span id="cb23-114"><a href="#cb23-114" aria-hidden="true" tabindex="-1"></a>best_per_party <span class="op">=</span> elections.loc[elections.groupby(<span class="st">'Party'</span>)[<span class="st">'%'</span>].idxmax()]</span>
<span id="cb23-115"><a href="#cb23-115" aria-hidden="true" tabindex="-1"></a>best_per_party.head(<span class="dv">5</span>)</span>
<span id="cb23-116"><a href="#cb23-116" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-117"><a href="#cb23-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-120"><a href="#cb23-120" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-121"><a href="#cb23-121" aria-hidden="true" tabindex="-1"></a><span class="co"># Using the .drop_duplicates function</span></span>
<span id="cb23-122"><a href="#cb23-122" aria-hidden="true" tabindex="-1"></a>best_per_party2 <span class="op">=</span> elections.sort_values(<span class="st">'%'</span>).drop_duplicates([<span class="st">'Party'</span>], keep<span class="op">=</span><span class="st">'last'</span>)</span>
<span id="cb23-123"><a href="#cb23-123" aria-hidden="true" tabindex="-1"></a>best_per_party2.head(<span class="dv">5</span>)</span>
<span id="cb23-124"><a href="#cb23-124" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-125"><a href="#cb23-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-126"><a href="#cb23-126" aria-hidden="true" tabindex="-1"></a><span class="fu">### Other `GroupBy` Features</span></span>
<span id="cb23-127"><a href="#cb23-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-128"><a href="#cb23-128" aria-hidden="true" tabindex="-1"></a>There are many aggregation methods we can use with <span class="in">`.agg`</span>. Some useful options are:</span>
<span id="cb23-129"><a href="#cb23-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-130"><a href="#cb23-130" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="co">[</span><span class="ot">`.mean`</span><span class="co">](https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.mean.html#pandas.core.groupby.DataFrameGroupBy.mean)</span>: creates a new DataFrame with the mean value of each group</span>
<span id="cb23-131"><a href="#cb23-131" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="co">[</span><span class="ot">`.sum`</span><span class="co">](https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.sum.html#pandas.core.groupby.DataFrameGroupBy.sum)</span>: creates a new DataFrame with the sum of each group</span>
<span id="cb23-132"><a href="#cb23-132" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="co">[</span><span class="ot">`.max`</span><span class="co">](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.core.groupby.GroupBy.max.html)</span> and <span class="co">[</span><span class="ot">`.min`</span><span class="co">](https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.min.html#pandas.core.groupby.DataFrameGroupBy.min)</span>: creates a new DataFrame with the maximum/minimum value of each group</span>
<span id="cb23-133"><a href="#cb23-133" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="co">[</span><span class="ot">`.size`</span><span class="co">](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.core.groupby.GroupBy.size.html)</span>: creates a new **Series** with the number of entries in each group</span>
<span id="cb23-134"><a href="#cb23-134" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="co">[</span><span class="ot">`.count`</span><span class="co">](https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count)</span>: creates a new **DataFrame** with the number of entries, excluding missing values. </span>
<span id="cb23-135"><a href="#cb23-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-136"><a href="#cb23-136" aria-hidden="true" tabindex="-1"></a>Note the slight difference between <span class="in">`.size()`</span> and <span class="in">`.count()`</span>: while <span class="in">`.size()`</span> returns a Series and counts the number of entries including the missing values, <span class="in">`.count()`</span> returns a DataFrame and counts the number of entries in each column excluding missing values. Here's an example:</span>
<span id="cb23-137"><a href="#cb23-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-140"><a href="#cb23-140" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-141"><a href="#cb23-141" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame({<span class="st">'letter'</span>:[<span class="st">'A'</span>,<span class="st">'A'</span>,<span class="st">'B'</span>,<span class="st">'C'</span>,<span class="st">'C'</span>,<span class="st">'C'</span>], </span>
<span id="cb23-142"><a href="#cb23-142" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'num'</span>:[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,np.NaN,<span class="dv">4</span>], </span>
<span id="cb23-143"><a href="#cb23-143" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'state'</span>:[np.NaN, <span class="st">'tx'</span>, <span class="st">'fl'</span>, <span class="st">'hi'</span>, np.NaN, <span class="st">'ak'</span>]})</span>
<span id="cb23-144"><a href="#cb23-144" aria-hidden="true" tabindex="-1"></a>df</span>
<span id="cb23-145"><a href="#cb23-145" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-146"><a href="#cb23-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-149"><a href="#cb23-149" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-150"><a href="#cb23-150" aria-hidden="true" tabindex="-1"></a>df.groupby(<span class="st">"letter"</span>).size()</span>
<span id="cb23-151"><a href="#cb23-151" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-152"><a href="#cb23-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-155"><a href="#cb23-155" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-156"><a href="#cb23-156" aria-hidden="true" tabindex="-1"></a>df.groupby(<span class="st">"letter"</span>).count()</span>
<span id="cb23-157"><a href="#cb23-157" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-158"><a href="#cb23-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-159"><a href="#cb23-159" aria-hidden="true" tabindex="-1"></a>You might recall <span class="in">`value_counts()`</span> function we talked about in the previous note. It turns out <span class="in">`value_counts()`</span> and <span class="in">`groupby.size()`</span> have similar functionalities, except <span class="in">`value_counts()`</span> sorts the result in descending order automatically. </span>
<span id="cb23-160"><a href="#cb23-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-163"><a href="#cb23-163" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-164"><a href="#cb23-164" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"letter"</span>].value_counts()</span>
<span id="cb23-165"><a href="#cb23-165" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-166"><a href="#cb23-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-167"><a href="#cb23-167" aria-hidden="true" tabindex="-1"></a>In fact, these (and other) aggregation functions are so common that <span class="in">`pandas`</span> allows for writing shorthand. Instead of explicitly stating the use of <span class="in">`.agg`</span>, we can call the function directly on the <span class="in">`GroupBy`</span> object.</span>
<span id="cb23-168"><a href="#cb23-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-169"><a href="#cb23-169" aria-hidden="true" tabindex="-1"></a>For example, the following are equivalent:</span>
<span id="cb23-170"><a href="#cb23-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-171"><a href="#cb23-171" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`elections.groupby("Candidate").agg(mean)`</span> </span>
<span id="cb23-172"><a href="#cb23-172" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`elections.groupby("Candidate").mean()`</span></span>
<span id="cb23-173"><a href="#cb23-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-174"><a href="#cb23-174" aria-hidden="true" tabindex="-1"></a>There are many other methods that <span class="in">`pandas`</span> supports. You can check them out on the <span class="co">[</span><span class="ot">`pandas` documentation</span><span class="co">](https://pandas.pydata.org/docs/reference/groupby.html)</span>.</span>
<span id="cb23-175"><a href="#cb23-175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-176"><a href="#cb23-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-177"><a href="#cb23-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-178"><a href="#cb23-178" aria-hidden="true" tabindex="-1"></a><span class="fu">### Filtering by Group</span></span>
<span id="cb23-179"><a href="#cb23-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-180"><a href="#cb23-180" aria-hidden="true" tabindex="-1"></a>Another common use for <span class="in">`GroupBy`</span> objects is to filter data by group. </span>
<span id="cb23-181"><a href="#cb23-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-182"><a href="#cb23-182" aria-hidden="true" tabindex="-1"></a><span class="in">`groupby.filter`</span> takes an argument $\text{f}$, where $\text{f}$ is a function that:</span>
<span id="cb23-183"><a href="#cb23-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-184"><a href="#cb23-184" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Takes a <span class="in">`GroupBy`</span> object as input</span>
<span id="cb23-185"><a href="#cb23-185" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Returns a single <span class="in">`True`</span> or <span class="in">`False`</span> for the entire sub-DataFrame</span>
<span id="cb23-186"><a href="#cb23-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-187"><a href="#cb23-187" aria-hidden="true" tabindex="-1"></a><span class="in">`GroupBy`</span> objects that correspond to <span class="in">`True`</span> are returned in the final result, whereas those with a <span class="in">`False`</span> value are not. Importantly, <span class="in">`groupby.filter`</span> is different from <span class="in">`groupby.agg`</span> in that the *entire* subframe is returned in the final DataFrame, not just a single row.</span>
<span id="cb23-188"><a href="#cb23-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-189"><a href="#cb23-189" aria-hidden="true" tabindex="-1"></a>To illustrate how this happens, consider the following <span class="in">`.filter`</span> function applied on some arbitrary data. Say we want to identify "tight" election years – that is, we want to find all rows that correspond to elections years where all candidates in that year won a similar portion of the total vote. Specifically, let's find all rows corresponding to a year where no candidate won more than 45% of the total vote. </span>
<span id="cb23-190"><a href="#cb23-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-191"><a href="#cb23-191" aria-hidden="true" tabindex="-1"></a>An equivalent way of framing this goal is to say: </span>
<span id="cb23-192"><a href="#cb23-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-193"><a href="#cb23-193" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Find the years where the maximum <span class="in">`%`</span> in that year is less than 45%</span>
<span id="cb23-194"><a href="#cb23-194" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Return all DataFrame rows that correspond to these years</span>
<span id="cb23-195"><a href="#cb23-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-196"><a href="#cb23-196" aria-hidden="true" tabindex="-1"></a>For each year, we need to find the maximum <span class="in">`%`</span> among *all* rows for that year. If this maximum <span class="in">`%`</span> is lower than 45%, we will tell <span class="in">`pandas`</span> to keep all rows corresponding to that year. </span>
<span id="cb23-197"><a href="#cb23-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-200"><a href="#cb23-200" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-201"><a href="#cb23-201" aria-hidden="true" tabindex="-1"></a>elections.groupby(<span class="st">"Year"</span>).<span class="bu">filter</span>(<span class="kw">lambda</span> sf: sf[<span class="st">"%"</span>].<span class="bu">max</span>() <span class="op">&lt;</span> <span class="dv">45</span>).head(<span class="dv">9</span>)</span>
<span id="cb23-202"><a href="#cb23-202" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-203"><a href="#cb23-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-204"><a href="#cb23-204" aria-hidden="true" tabindex="-1"></a>What's going on here? In this example, we've defined our filtering function, $\text{f}$, to be <span class="in">`lambda sf: sf["%"].max() &lt; 45`</span>. This filtering function will find the maximum <span class="in">`"%"`</span> value among all entries in the grouped subframe, which we call <span class="in">`sf`</span>. If the maximum value is less than 45, then the filter function will return <span class="in">`True`</span> and all rows in that grouped subframe will appear in the final output DataFrame. </span>
<span id="cb23-205"><a href="#cb23-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-206"><a href="#cb23-206" aria-hidden="true" tabindex="-1"></a>Examine the DataFrame above. Notice how, in this preview of the first 9 rows, all entries from the years 1860 and 1912 appear. This means that in 1860 and 1912, no candidate in that year won more than 45% of the total vote. </span>
<span id="cb23-207"><a href="#cb23-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-208"><a href="#cb23-208" aria-hidden="true" tabindex="-1"></a>You may ask: how is the <span class="in">`groupby.filter`</span> procedure different to the boolean filtering we've seen previously? Boolean filtering considers *individual* rows when applying a boolean condition. For example, the code `elections[elections["%"] &lt; 45]` will check the `"%"` value of every single row in `elections`; if it is less than 45, then that row will be kept in the output. `groupby.filter`, in contrast, applies a boolean condition *across* all rows in a group. If not all rows in that group satisfy the condition specified by the filter, the entire group will be discarded in the output. </span>
<span id="cb23-209"><a href="#cb23-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-210"><a href="#cb23-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-211"><a href="#cb23-211" aria-hidden="true" tabindex="-1"></a><span class="fu">## Aggregating Data with Pivot Tables</span></span>
<span id="cb23-212"><a href="#cb23-212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-213"><a href="#cb23-213" aria-hidden="true" tabindex="-1"></a>We know now that <span class="in">`.groupby`</span> gives us the ability to group and aggregate data across our DataFrame. The examples above formed groups using just one column in the DataFrame. It's possible to group by multiple columns at once by passing in a list of columns names to <span class="in">`.groupby`</span>. </span>
<span id="cb23-214"><a href="#cb23-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-215"><a href="#cb23-215" aria-hidden="true" tabindex="-1"></a>Let's consider the <span class="in">`babynames`</span> dataset from last lecture. In this problem, we will find the total number of baby names associated with each sex for each year. To do this, we'll group by *both* the <span class="in">`"Year"`</span> and <span class="in">`"Sex"`</span> columns.</span>
<span id="cb23-216"><a href="#cb23-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-219"><a href="#cb23-219" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-220"><a href="#cb23-220" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb23-221"><a href="#cb23-221" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> urllib.request</span>
<span id="cb23-222"><a href="#cb23-222" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os.path</span>
<span id="cb23-223"><a href="#cb23-223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-224"><a href="#cb23-224" aria-hidden="true" tabindex="-1"></a><span class="co"># Download data from the web directly</span></span>
<span id="cb23-225"><a href="#cb23-225" aria-hidden="true" tabindex="-1"></a>data_url <span class="op">=</span> <span class="st">"https://www.ssa.gov/oact/babynames/names.zip"</span></span>
<span id="cb23-226"><a href="#cb23-226" aria-hidden="true" tabindex="-1"></a>local_filename <span class="op">=</span> <span class="st">"data/babynames.zip"</span></span>
<span id="cb23-227"><a href="#cb23-227" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> os.path.exists(local_filename): <span class="co"># if the data exists don't download again</span></span>
<span id="cb23-228"><a href="#cb23-228" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> urllib.request.urlopen(data_url) <span class="im">as</span> resp, <span class="bu">open</span>(local_filename, <span class="st">'wb'</span>) <span class="im">as</span> f:</span>
<span id="cb23-229"><a href="#cb23-229" aria-hidden="true" tabindex="-1"></a>        f.write(resp.read())</span>
<span id="cb23-230"><a href="#cb23-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-231"><a href="#cb23-231" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb23-232"><a href="#cb23-232" aria-hidden="true" tabindex="-1"></a><span class="co"># Load data without unzipping the file</span></span>
<span id="cb23-233"><a href="#cb23-233" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> zipfile</span>
<span id="cb23-234"><a href="#cb23-234" aria-hidden="true" tabindex="-1"></a>babynames <span class="op">=</span> [] </span>
<span id="cb23-235"><a href="#cb23-235" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> zipfile.ZipFile(local_filename, <span class="st">"r"</span>) <span class="im">as</span> zf:</span>
<span id="cb23-236"><a href="#cb23-236" aria-hidden="true" tabindex="-1"></a>    data_files <span class="op">=</span> [f <span class="cf">for</span> f <span class="kw">in</span> zf.filelist <span class="cf">if</span> f.filename[<span class="op">-</span><span class="dv">3</span>:] <span class="op">==</span> <span class="st">"txt"</span>]</span>
<span id="cb23-237"><a href="#cb23-237" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> extract_year_from_filename(fn):</span>
<span id="cb23-238"><a href="#cb23-238" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">int</span>(fn[<span class="dv">3</span>:<span class="dv">7</span>])</span>
<span id="cb23-239"><a href="#cb23-239" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> f <span class="kw">in</span> data_files:</span>
<span id="cb23-240"><a href="#cb23-240" aria-hidden="true" tabindex="-1"></a>        year <span class="op">=</span> extract_year_from_filename(f.filename)</span>
<span id="cb23-241"><a href="#cb23-241" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> zf.<span class="bu">open</span>(f) <span class="im">as</span> fp:</span>
<span id="cb23-242"><a href="#cb23-242" aria-hidden="true" tabindex="-1"></a>            df <span class="op">=</span> pd.read_csv(fp, names<span class="op">=</span>[<span class="st">"Name"</span>, <span class="st">"Sex"</span>, <span class="st">"Count"</span>])</span>
<span id="cb23-243"><a href="#cb23-243" aria-hidden="true" tabindex="-1"></a>            df[<span class="st">"Year"</span>] <span class="op">=</span> year</span>
<span id="cb23-244"><a href="#cb23-244" aria-hidden="true" tabindex="-1"></a>            babynames.append(df)</span>
<span id="cb23-245"><a href="#cb23-245" aria-hidden="true" tabindex="-1"></a>babynames <span class="op">=</span> pd.concat(babynames)</span>
<span id="cb23-246"><a href="#cb23-246" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-247"><a href="#cb23-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-250"><a href="#cb23-250" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-251"><a href="#cb23-251" aria-hidden="true" tabindex="-1"></a>babynames.head()</span>
<span id="cb23-252"><a href="#cb23-252" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-253"><a href="#cb23-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-256"><a href="#cb23-256" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-257"><a href="#cb23-257" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: false</span></span>
<span id="cb23-258"><a href="#cb23-258" aria-hidden="true" tabindex="-1"></a><span class="co"># Find the total number of baby names associated with each sex for each year in the data</span></span>
<span id="cb23-259"><a href="#cb23-259" aria-hidden="true" tabindex="-1"></a>babynames.groupby([<span class="st">"Year"</span>, <span class="st">"Sex"</span>])[[<span class="st">"Count"</span>]].agg(<span class="bu">sum</span>).head(<span class="dv">6</span>)</span>
<span id="cb23-260"><a href="#cb23-260" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-261"><a href="#cb23-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-262"><a href="#cb23-262" aria-hidden="true" tabindex="-1"></a>Notice that both <span class="in">`"Year"`</span> and <span class="in">`"Sex"`</span> serve as the index of the DataFrame (they are both rendered in bold). We've created a *multindex* where two different index values, the year and sex, are used to uniquely identify each row. </span>
<span id="cb23-263"><a href="#cb23-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-264"><a href="#cb23-264" aria-hidden="true" tabindex="-1"></a>This isn't the most intuitive way of representing this data – and, because multindexes have multiple dimensions in their index, they can often be difficult to use. </span>
<span id="cb23-265"><a href="#cb23-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-266"><a href="#cb23-266" aria-hidden="true" tabindex="-1"></a>Another strategy to aggregate across two columns is to create a pivot table. You saw these back in <span class="co">[</span><span class="ot">Data 8</span><span class="co">](https://inferentialthinking.com/chapters/08/3/Cross-Classifying_by_More_than_One_Variable.html#pivot-tables-rearranging-the-output-of-group)</span>. One set of values is used to create the index of the table; another set is used to define the column names. The values contained in each cell of the table correspond to the aggregated data for each index-column pair.</span>
<span id="cb23-267"><a href="#cb23-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-268"><a href="#cb23-268" aria-hidden="true" tabindex="-1"></a>The best way to understand pivot tables is to see one in action. Let's return to our original goal of summing the total number of names associated with each combination of year and sex. We'll call the <span class="in">`pandas`</span> <span class="co">[</span><span class="ot">`.pivot_table`</span><span class="co">](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.pivot_table.html)</span> method to create a new table.</span>
<span id="cb23-269"><a href="#cb23-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-272"><a href="#cb23-272" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-273"><a href="#cb23-273" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: false</span></span>
<span id="cb23-274"><a href="#cb23-274" aria-hidden="true" tabindex="-1"></a><span class="co"># The `pivot_table` method is used to generate a Pandas pivot table</span></span>
<span id="cb23-275"><a href="#cb23-275" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb23-276"><a href="#cb23-276" aria-hidden="true" tabindex="-1"></a>babynames.pivot_table(index <span class="op">=</span> <span class="st">"Year"</span>, columns <span class="op">=</span> <span class="st">"Sex"</span>, values <span class="op">=</span> <span class="st">"Count"</span>, aggfunc <span class="op">=</span> np.<span class="bu">sum</span>).head(<span class="dv">5</span>)</span>
<span id="cb23-277"><a href="#cb23-277" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-278"><a href="#cb23-278" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-279"><a href="#cb23-279" aria-hidden="true" tabindex="-1"></a>Looks a lot better! Now, our DataFrame is structured with clear index-column combinations. Each entry in the pivot table represents the summed count of names for a given combination of <span class="in">`"Year"`</span> and <span class="in">`"Sex"`</span>.</span>
<span id="cb23-280"><a href="#cb23-280" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-281"><a href="#cb23-281" aria-hidden="true" tabindex="-1"></a>Let's take a closer look at the code implemented above. </span>
<span id="cb23-282"><a href="#cb23-282" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-283"><a href="#cb23-283" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`index = "Year"`</span> specifies the column name in the original DataFrame that should be used as the index of the pivot table</span>
<span id="cb23-284"><a href="#cb23-284" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`columns = "Sex"`</span> specifies the column name in the original DataFrame that should be used to generate the columns of the pivot table</span>
<span id="cb23-285"><a href="#cb23-285" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`values = "Count"`</span> indicates what values from the original DataFrame should be used to populate the entry for each index-column combination</span>
<span id="cb23-286"><a href="#cb23-286" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`aggfunc = np.sum`</span> tells <span class="in">`pandas`</span> what function to use when aggregating the data specified by <span class="in">`values`</span>. Here, we are <span class="in">`sum`</span>ming the name counts for each pair of <span class="in">`"Year"`</span> and <span class="in">`"Sex"`</span></span>
<span id="cb23-287"><a href="#cb23-287" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-288"><a href="#cb23-288" aria-hidden="true" tabindex="-1"></a>We can even include multiple values in the index or columns of our pivot tables.</span>
<span id="cb23-289"><a href="#cb23-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-292"><a href="#cb23-292" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-293"><a href="#cb23-293" aria-hidden="true" tabindex="-1"></a>babynames_pivot <span class="op">=</span> babynames.pivot_table(</span>
<span id="cb23-294"><a href="#cb23-294" aria-hidden="true" tabindex="-1"></a>    index<span class="op">=</span><span class="st">"Year"</span>,     <span class="co"># the rows (turned into index)</span></span>
<span id="cb23-295"><a href="#cb23-295" aria-hidden="true" tabindex="-1"></a>    columns<span class="op">=</span><span class="st">"Sex"</span>,    <span class="co"># the column values</span></span>
<span id="cb23-296"><a href="#cb23-296" aria-hidden="true" tabindex="-1"></a>    values<span class="op">=</span>[<span class="st">"Count"</span>, <span class="st">"Name"</span>], </span>
<span id="cb23-297"><a href="#cb23-297" aria-hidden="true" tabindex="-1"></a>    aggfunc<span class="op">=</span><span class="bu">max</span>,   <span class="co"># group operation</span></span>
<span id="cb23-298"><a href="#cb23-298" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb23-299"><a href="#cb23-299" aria-hidden="true" tabindex="-1"></a>babynames_pivot.head(<span class="dv">6</span>)</span>
<span id="cb23-300"><a href="#cb23-300" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-301"><a href="#cb23-301" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-302"><a href="#cb23-302" aria-hidden="true" tabindex="-1"></a><span class="fu">## Joining Tables </span></span>
<span id="cb23-303"><a href="#cb23-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-304"><a href="#cb23-304" aria-hidden="true" tabindex="-1"></a>When working on data science projects, we're unlikely to have absolutely all the data we want contained in a single DataFrame – a real-world data scientist needs to grapple with data coming from multiple sources. If we have access to multiple datasets with related information, we can join two or more tables into a single DataFrame. </span>
<span id="cb23-305"><a href="#cb23-305" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-306"><a href="#cb23-306" aria-hidden="true" tabindex="-1"></a>To put this into practice, we'll revisit the <span class="in">`elections`</span> dataset.</span>
<span id="cb23-307"><a href="#cb23-307" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-310"><a href="#cb23-310" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-311"><a href="#cb23-311" aria-hidden="true" tabindex="-1"></a>elections.head(<span class="dv">5</span>)</span>
<span id="cb23-312"><a href="#cb23-312" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-313"><a href="#cb23-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-314"><a href="#cb23-314" aria-hidden="true" tabindex="-1"></a>Say we want to understand the 2020 popularity of the names of each presidential candidate. To do this, we'll need the combined data of <span class="in">`babynames`</span> *and* <span class="in">`elections`</span>. </span>
<span id="cb23-315"><a href="#cb23-315" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-316"><a href="#cb23-316" aria-hidden="true" tabindex="-1"></a>We'll start by creating a new column containing the first name of each presidential candidate. This will help us join each name in <span class="in">`elections`</span> to the corresponding name data in <span class="in">`babynames`</span>. </span>
<span id="cb23-317"><a href="#cb23-317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-320"><a href="#cb23-320" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-321"><a href="#cb23-321" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: false</span></span>
<span id="cb23-322"><a href="#cb23-322" aria-hidden="true" tabindex="-1"></a><span class="co"># This `str` operation splits each candidate's full name at each </span></span>
<span id="cb23-323"><a href="#cb23-323" aria-hidden="true" tabindex="-1"></a><span class="co"># blank space, then takes just the candidiate's first name</span></span>
<span id="cb23-324"><a href="#cb23-324" aria-hidden="true" tabindex="-1"></a>elections[<span class="st">"First Name"</span>] <span class="op">=</span> elections[<span class="st">"Candidate"</span>].<span class="bu">str</span>.split().<span class="bu">str</span>[<span class="dv">0</span>]</span>
<span id="cb23-325"><a href="#cb23-325" aria-hidden="true" tabindex="-1"></a>elections.head(<span class="dv">5</span>)</span>
<span id="cb23-326"><a href="#cb23-326" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-327"><a href="#cb23-327" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-330"><a href="#cb23-330" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-331"><a href="#cb23-331" aria-hidden="true" tabindex="-1"></a><span class="co"># Here, we'll only consider `babynames` data from 2020</span></span>
<span id="cb23-332"><a href="#cb23-332" aria-hidden="true" tabindex="-1"></a>babynames_2020 <span class="op">=</span> babynames[babynames[<span class="st">"Year"</span>]<span class="op">==</span><span class="dv">2020</span>]</span>
<span id="cb23-333"><a href="#cb23-333" aria-hidden="true" tabindex="-1"></a>babynames_2020.head()</span>
<span id="cb23-334"><a href="#cb23-334" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-335"><a href="#cb23-335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-336"><a href="#cb23-336" aria-hidden="true" tabindex="-1"></a>Now, we're ready to join the two tables. <span class="co">[</span><span class="ot">`pd.merge`</span><span class="co">](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.merge.html)</span> is the <span class="in">`pandas`</span> method used to join DataFrames together. The <span class="in">`left`</span> and <span class="in">`right`</span> parameters are used to specify the DataFrames to be joined. The <span class="in">`left_on`</span> and <span class="in">`right_on`</span> parameters are assigned to the string names of the columns to be used when performing the join. These two <span class="in">`on`</span> parameters tell <span class="in">`pandas`</span> what values should act as pairing keys to determine which rows to merge across the DataFrames. We'll talk more about this idea of a pairing key next lecture.</span>
<span id="cb23-337"><a href="#cb23-337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-340"><a href="#cb23-340" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb23-341"><a href="#cb23-341" aria-hidden="true" tabindex="-1"></a><span class="co">#| tags: []</span></span>
<span id="cb23-342"><a href="#cb23-342" aria-hidden="true" tabindex="-1"></a>merged <span class="op">=</span> pd.merge(left <span class="op">=</span> elections, right <span class="op">=</span> babynames_2020, <span class="op">\</span></span>
<span id="cb23-343"><a href="#cb23-343" aria-hidden="true" tabindex="-1"></a>                  left_on <span class="op">=</span> <span class="st">"First Name"</span>, right_on <span class="op">=</span> <span class="st">"Name"</span>)</span>
<span id="cb23-344"><a href="#cb23-344" aria-hidden="true" tabindex="-1"></a>merged.head()</span>
<span id="cb23-345"><a href="#cb23-345" aria-hidden="true" tabindex="-1"></a><span class="co"># Notice that pandas automatically specifies `Year_x` and `Year_y` </span></span>
<span id="cb23-346"><a href="#cb23-346" aria-hidden="true" tabindex="-1"></a><span class="co"># when both merged DataFrames have the same column name to avoid confusion</span></span>
<span id="cb23-347"><a href="#cb23-347" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->



</body></html>